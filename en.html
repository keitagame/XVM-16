<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>XVM-16 Complete Specification</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
    }
    @font-face {
        font-family: "Renner";
        src: url("./Renner.ttf") format("truetype");
        font-display: swap;
      }
    body {
      background: #000;
      font-family: "Renner",sans-serif;
      margin: 0;
      padding: 20px;
      color: #fff;
      line-height: 1.6;
    }
    h1 {
      font-size: 32px;
      font-weight: 300;
      border-bottom: 2px solid #0f0;
      padding-bottom: 10px;
    }
    h2 {
      font-size: 24px;
      font-weight: 400;
      color: #0ff;
      margin-top: 40px;
    }
    h3 {
      font-size: 20px;
      font-weight: 400;
      color: #ff0;
      margin-top: 30px;
    }
    h4 {
      font-size: 16px;
      font-weight: 500;
      color: #f0f;
      margin-top: 20px;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      font-size: 14px;
    }
    th, td {
      border: 1px solid #444;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background: #1a1a1a;
      font-weight: 500;
    }
    code {
      background: #1a1a1a;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      color: #0f0;
    }
    pre {
      background: #0f0f0f;
      border: 1px solid #333;
      padding: 15px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    .note {
      background: #1a1a00;
      border-left: 4px solid #ff0;
      padding: 12px 15px;
      margin: 15px 0;
    }
    .important {
      background: #1a0000;
      border-left: 4px solid #f00;
      padding: 12px 15px;
      margin: 15px 0;
    }
    .info {
      background: #001a1a;
      border-left: 4px solid #0ff;
      padding: 12px 15px;
      margin: 15px 0;
    }
    .spec-box {
      background: #0a0a0a;
      border: 2px solid #0f0;
      padding: 20px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>XVM-16 Complete Specification</h1>
    <p style="color: #888;">Advanced 8-bit Virtual Machine - Game Development Edition</p>

    <div class="spec-box">
      <strong style="color: #0f0;">Concept:</strong> 
      A practical 8-bit virtual machine for game development. Features 256x256 resolution, 256 color palette, 4-channel sound, 
      and controller input. A modern reimagining of NES/MSX-era capabilities.
    </div>

    <h2>1. Basic Specifications</h2>
    
    <h3>1.1 CPU</h3>
    <ul>
      <li><strong>Architecture:</strong> 8-bit CPU</li>
      <li><strong>Address Space:</strong> 16-bit (64KB)</li>
      <li><strong>Clock Speed:</strong> 4MHz</li>
      <li><strong>Refresh Rate:</strong> 60Hz</li>
      <li><strong>Cycles/Frame:</strong> 66,667 cycles</li>
    </ul>

    <h3>1.2 Registers</h3>
    <table>
      <tr><th>Name</th><th>Size</th><th>Description</th></tr>
      <tr><td><code>A</code></td><td>8-bit</td><td>General-purpose accumulator</td></tr>
      <tr><td><code>B</code></td><td>8-bit</td><td>General-purpose register</td></tr>
      <tr><td><code>C</code></td><td>8-bit</td><td>General-purpose register (counter usage)</td></tr>
      <tr><td><code>D</code></td><td>8-bit</td><td>General-purpose register (data usage)</td></tr>
      <tr><td><code>X</code></td><td>8-bit</td><td>X index register</td></tr>
      <tr><td><code>Y</code></td><td>8-bit</td><td>Y index register</td></tr>
      <tr><td><code>SP</code></td><td>16-bit</td><td>Stack pointer (initial: 0x7FFF)</td></tr>
      <tr><td><code>PC</code></td><td>16-bit</td><td>Program counter (initial: 0xE000)</td></tr>
      <tr><td><code>F</code></td><td>8-bit</td><td>Flags register</td></tr>
    </table>

    <h4>Flags Register (F)</h4>
    <table>
      <tr><th>Bit</th><th>Name</th><th>Description</th></tr>
      <tr><td>bit 0</td><td>Z (Zero)</td><td>Result is zero</td></tr>
      <tr><td>bit 1</td><td>C (Carry)</td><td>Carry/borrow occurred</td></tr>
      <tr><td>bit 2</td><td>N (Negative)</td><td>Result is negative (bit7=1)</td></tr>
      <tr><td>bit 3</td><td>V (Overflow)</td><td>Signed overflow occurred</td></tr>
      <tr><td>bit 4-7</td><td>-</td><td>Unused (always 0)</td></tr>
    </table>

    <h3>1.3 Memory Map</h3>
    <table>
      <tr><th>Address</th><th>Size</th><th>Description</th></tr>
      <tr><td>0x0000-0x00FF</td><td>256B</td><td>Zero Page RAM (fast access)</td></tr>
      <tr><td>0x0100-0x01FF</td><td>256B</td><td>Stack area</td></tr>
      <tr><td>0x0200-0x7FFF</td><td>31.5KB</td><td>General-purpose RAM</td></tr>
      <tr><td>0x8000-0xFFFF</td><td>32KB</td><td><strong>VRAM (Graphics)</strong></td></tr>
      <tr><td>0xD000-0xD0FF</td><td>256B</td><td>Palette memory (256 colors)</td></tr>
      <tr><td>0xD100-0xD1FF</td><td>256B</td><td>Sprite attribute table (64 sprites)</td></tr>
      <tr><td>0xD200-0xD2FF</td><td>256B</td><td>Sound registers</td></tr>
      <tr><td>0xD300-0xD3FF</td><td>256B</td><td>I/O registers</td></tr>
      <tr><td>0xE000-0xFFFF</td><td>8KB</td><td>ROM (Program area)</td></tr>
    </table>

    <div class="important">
      <strong>Memory Overlap:</strong> The 0xD000-0xDFFF region overlaps VRAM and I/O registers.
      Reads access I/O registers, writes affect both VRAM and I/O.
    </div>

    <h2>2. Graphics Specifications</h2>

    <h3>2.1 Display</h3>
    <ul>
      <li><strong>Resolution:</strong> 256x256 pixels</li>
      <li><strong>Colors:</strong> 256 colors (8-bit indexed color)</li>
      <li><strong>VRAM Size:</strong> 65,536 bytes (256x256)</li>
      <li><strong>Sprites:</strong> 64 sprites (16x16 pixels each)</li>
      <li><strong>Layers:</strong> Background + Sprites (2 layers)</li>
    </ul>

    <h3>2.2 VRAM Layout</h3>
    <table>
      <tr><th>Address</th><th>Contents</th></tr>
      <tr><td>0x8000-0xFFFF</td><td>BG pixel data (256x256)</td></tr>
      <tr><td>Formula</td><td><code>VRAM[y * 256 + x] = color_index(0-255)</code></td></tr>
    </table>

    <h3>2.3 Color Palette</h3>
    <p><strong>Address:</strong> 0xD000-0xD0FF (256 colors)</p>
    <p><strong>Format:</strong> RGB332 (8-bit)</p>
    <pre>RGB332 Format:
RRR GGG BB
|||  |  ||
|||  |  ++-- Blue (0-3)   ×85 → 0-255
|||  +------ Green (0-7)  ×36 → 0-252
+++--------- Red (0-7)    ×36 → 0-252

Conversion formula:
R8 = ((RGB332 >> 5) & 0x07) * 36
G8 = ((RGB332 >> 2) & 0x07) * 36
B8 = (RGB332 & 0x03) * 85</pre>

    <div class="note">
      <strong>Default Palette (first 16 colors):</strong><br>
      0: 0x00 (black), 1: 0xFF (white), 2: 0xE0 (red), 3: 0x1C (green), 
      4: 0x03 (blue), 5: 0xFC (yellow), 6: 0xE3 (magenta), 7: 0x1F (cyan),
      8: 0x92 (gray), 9: 0x6D (brown), 10: 0xB8 (orange), 11: 0x9F (lime),
      12: 0x13 (aqua), 13: 0xA3 (purple), 14: 0xFD (pink), 15: 0xB6 (beige)
    </div>

    <h3>2.4 Sprite Specifications</h3>
    <p><strong>Sprite Count:</strong> Maximum 64 sprites</p>
    <p><strong>Size:</strong> 16x16 pixels (fixed)</p>
    <p><strong>Attribute Table:</strong> 0xD100-0xD1FF (4 bytes per sprite)</p>

    <h4>Sprite Attributes (4 bytes/sprite)</h4>
    <table>
      <tr><th>Offset</th><th>Contents</th></tr>
      <tr><td>+0</td><td>X coordinate (0-255)</td></tr>
      <tr><td>+1</td><td>Y coordinate (0-255)</td></tr>
      <tr><td>+2</td><td>Tile number (0-255)</td></tr>
      <tr><td>+3</td><td>Flags (bit0=enable, bit1=flip_x, bit2=flip_y)</td></tr>
    </table>

    <p><strong>Sprite Tile Data:</strong> RAM 0x2000-0x5FFF (16KB, 256 tiles)</p>
    <p>Each tile = 16x16 = 256 bytes</p>

    <h2>3. Sound Specifications</h2>

    <h3>3.1 Sound Chip Specs</h3>
    <ul>
      <li><strong>Channels:</strong> 4 channels</li>
      <li><strong>Waveform:</strong> Square wave (variable duty cycle)</li>
      <li><strong>Sample Rate:</strong> 44.1kHz</li>
      <li><strong>Bit Depth:</strong> 8-bit</li>
    </ul>

    <h3>3.2 Sound Registers</h3>
    <p><strong>Base Address:</strong> 0xD200-0xD2FF</p>

    <table>
      <tr><th>Address</th><th>Contents</th></tr>
      <tr><td>0xD200 + (ch*8) + 0</td><td>Frequency low byte</td></tr>
      <tr><td>0xD200 + (ch*8) + 1</td><td>Frequency high byte</td></tr>
      <tr><td>0xD200 + (ch*8) + 2</td><td>Volume (0-15)</td></tr>
      <tr><td>0xD200 + (ch*8) + 3</td><td>Duty cycle (0=12.5%, 1=25%, 2=50%, 3=75%)</td></tr>
      <tr><td>0xD200 + (ch*8) + 4</td><td>Envelope speed (0-15, 0=none)</td></tr>
      <tr><td>0xD200 + (ch*8) + 5</td><td>Flags (bit0=enable, bit1=loop, bit2=decay)</td></tr>
      <tr><td>0xD200 + (ch*8) + 6</td><td>Reserved</td></tr>
      <tr><td>0xD200 + (ch*8) + 7</td><td>Reserved</td></tr>
    </table>

    <h4>Frequency Calculation</h4>
    <pre>Frequency value = 4000000 / (32 * target_frequency)

Example: A4 (440Hz)
Frequency value = 4000000 / (32 * 440) = 284 (0x011C)
→ Low byte=0x1C, High byte=0x01</pre>

    <div class="info">
      <strong>Musical Note Table Example:</strong><br>
      C4=262Hz(val:478), D4=294Hz(val:426), E4=330Hz(val:379), F4=349Hz(val:358),
      G4=392Hz(val:319), A4=440Hz(val:284), B4=494Hz(val:253), C5=523Hz(val:239)
    </div>

    <h2>4. Input Specifications</h2>

    <h3>4.1 Controller</h3>
    <p><strong>I/O Address:</strong> 0xD300-0xD301</p>

    <table>
      <tr><th>Address</th><th>Contents</th></tr>
      <tr><td>0xD300</td><td>Controller 1 state</td></tr>
      <tr><td>0xD301</td><td>Controller 2 state</td></tr>
    </table>

    <h4>Button Layout (8-bit)</h4>
    <table>
      <tr><th>Bit</th><th>Button</th></tr>
      <tr><td>bit 0</td><td>Up</td></tr>
      <tr><td>bit 1</td><td>Down</td></tr>
      <tr><td>bit 2</td><td>Left</td></tr>
      <tr><td>bit 3</td><td>Right</td></tr>
      <tr><td>bit 4</td><td>A Button</td></tr>
      <tr><td>bit 5</td><td>B Button</td></tr>
      <tr><td>bit 6</td><td>START Button</td></tr>
      <tr><td>bit 7</td><td>SELECT Button</td></tr>
    </table>

    <div class="note">
      <strong>Reading Example:</strong><br>
      <code>LD A, [0xD300]</code> to read, each bit is 1=pressed, 0=not pressed
    </div>

    <h3>4.2 Other Inputs</h3>
    <table>
      <tr><th>Address</th><th>Contents</th></tr>
      <tr><td>0xD302</td><td>Random number generator (read-only, 0-255 random value)</td></tr>
      <tr><td>0xD303</td><td>Frame counter low byte (0-255 loop)</td></tr>
      <tr><td>0xD304</td><td>Frame counter high byte (16-bit total count)</td></tr>
    </table>

    <h2>5. Extended Instruction Set</h2>

    <h3>5.1 Data Transfer Instructions</h3>
    <table>
      <thead>
        <tr><th>Mnemonic</th><th>Opcode</th><th>Cycles</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr><td>NOP</td><td>0x00</td><td>1</td><td>No operation</td></tr>
        <tr><td>LD A, #n</td><td>0x01 nn</td><td>2</td><td>A = n</td></tr>
        <tr><td>LD B, #n</td><td>0x02 nn</td><td>2</td><td>B = n</td></tr>
        <tr><td>LD C, #n</td><td>0x03 nn</td><td>2</td><td>C = n</td></tr>
        <tr><td>LD D, #n</td><td>0x04 nn</td><td>2</td><td>D = n</td></tr>
        <tr><td>LD X, #n</td><td>0x05 nn</td><td>2</td><td>X = n</td></tr>
        <tr><td>LD Y, #n</td><td>0x06 nn</td><td>2</td><td>Y = n</td></tr>
        <tr><td>LD A, [addr]</td><td>0x07 LL HH</td><td>4</td><td>A = memory[addr]</td></tr>
        <tr><td>LD B, [addr]</td><td>0x08 LL HH</td><td>4</td><td>B = memory[addr]</td></tr>
        <tr><td>ST A, [addr]</td><td>0x09 LL HH</td><td>4</td><td>memory[addr] = A</td></tr>
        <tr><td>ST B, [addr]</td><td>0x0A LL HH</td><td>4</td><td>memory[addr] = B</td></tr>
        <tr><td>LD A, [X]</td><td>0x0B</td><td>3</td><td>A = memory[0x00XX] (zero page)</td></tr>
        <tr><td>ST A, [X]</td><td>0x0C</td><td>3</td><td>memory[0x00XX] = A</td></tr>
        <tr><td>LD A, [addr+X]</td><td>0x0D LL HH</td><td>5</td><td>A = memory[addr+X]</td></tr>
        <tr><td>ST A, [addr+X]</td><td>0x0E LL HH</td><td>5</td><td>memory[addr+X] = A</td></tr>
        <tr><td>LD A, [addr+Y]</td><td>0x0F LL HH</td><td>5</td><td>A = memory[addr+Y]</td></tr>
      </tbody>
    </table>

    <h3>5.2 Register Transfer Instructions</h3>
    <table>
      <tr><th>Mnemonic</th><th>Opcode</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>MOV A, B</td><td>0x10</td><td>1</td><td>A = B</td></tr>
      <tr><td>MOV A, C</td><td>0x11</td><td>1</td><td>A = C</td></tr>
      <tr><td>MOV A, D</td><td>0x12</td><td>1</td><td>A = D</td></tr>
      <tr><td>MOV A, X</td><td>0x13</td><td>1</td><td>A = X</td></tr>
      <tr><td>MOV A, Y</td><td>0x14</td><td>1</td><td>A = Y</td></tr>
      <tr><td>MOV B, A</td><td>0x15</td><td>1</td><td>B = A</td></tr>
      <tr><td>MOV C, A</td><td>0x16</td><td>1</td><td>C = A</td></tr>
      <tr><td>MOV D, A</td><td>0x17</td><td>1</td><td>D = A</td></tr>
      <tr><td>MOV X, A</td><td>0x18</td><td>1</td><td>X = A</td></tr>
      <tr><td>MOV Y, A</td><td>0x19</td><td>1</td><td>Y = A</td></tr>
      <tr><td>MOV X, Y</td><td>0x1A</td><td>1</td><td>X = Y</td></tr>
      <tr><td>MOV Y, X</td><td>0x1B</td><td>1</td><td>Y = X</td></tr>
    </table>

    <h3>5.3 Arithmetic & Logic Instructions</h3>
    <table>
      <tr><th>Mnemonic</th><th>Opcode</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>ADD A, B</td><td>0x20</td><td>1</td><td>A = A + B (updates flags)</td></tr>
      <tr><td>ADD A, #n</td><td>0x21 nn</td><td>2</td><td>A = A + n</td></tr>
      <tr><td>SUB A, B</td><td>0x22</td><td>1</td><td>A = A - B (updates flags)</td></tr>
      <tr><td>SUB A, #n</td><td>0x23 nn</td><td>2</td><td>A = A - n</td></tr>
      <tr><td>AND A, B</td><td>0x24</td><td>1</td><td>A = A & B</td></tr>
      <tr><td>OR A, B</td><td>0x25</td><td>1</td><td>A = A | B</td></tr>
      <tr><td>XOR A, B</td><td>0x26</td><td>1</td><td>A = A ^ B</td></tr>
      <tr><td>CMP A, B</td><td>0x27</td><td>1</td><td>Compare A - B (flags only)</td></tr>
      <tr><td>CMP A, #n</td><td>0x28 nn</td><td>2</td><td>Compare A - n</td></tr>
      <tr><td>INC A</td><td>0x29</td><td>1</td><td>A++</td></tr>
      <tr><td>INC B</td><td>0x2A</td><td>1</td><td>B++</td></tr>
      <tr><td>INC C</td><td>0x2B</td><td>1</td><td>C++</td></tr>
      <tr><td>INC D</td><td>0x2C</td><td>1</td><td>D++</td></tr>
      <tr><td>INC X</td><td>0x2D</td><td>1</td><td>X++</td></tr>
      <tr><td>INC Y</td><td>0x2E</td><td>1</td><td>Y++</td></tr>
      <tr><td>DEC A</td><td>0x2F</td><td>1</td><td>A--</td></tr>
      <tr><td>DEC B</td><td>0x30</td><td>1</td><td>B--</td></tr>
      <tr><td>DEC X</td><td>0x31</td><td>1</td><td>X--</td></tr>
      <tr><td>DEC Y</td><td>0x32</td><td>1</td><td>Y--</td></tr>
    </table>

    <h3>5.4 Shift & Rotate Instructions</h3>
    <table>
      <tr><th>Mnemonic</th><th>Opcode</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>SHL A</td><td>0x33</td><td>1</td><td>A = A << 1 (logical left shift)</td></tr>
      <tr><td>SHR A</td><td>0x34</td><td>1</td><td>A = A >> 1 (logical right shift)</td></tr>
      <tr><td>ROL A</td><td>0x35</td><td>1</td><td>A = rotate left (through carry)</td></tr>
      <tr><td>ROR A</td><td>0x36</td><td>1</td><td>A = rotate right (through carry)</td></tr>
    </table>

    <h3>5.5 Jump & Branch Instructions</h3>
    <table>
      <tr><th>Mnemonic</th><th>Opcode</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>JMP addr</td><td>0x40 LL HH</td><td>3</td><td>Unconditional jump</td></tr>
      <tr><td>JE addr</td><td>0x41 LL HH</td><td>3/2</td><td>Jump if Z=1 (equal)</td></tr>
      <tr><td>JNE addr</td><td>0x42 LL HH</td><td>3/2</td><td>Jump if Z=0 (not equal)</td></tr>
      <tr><td>JC addr</td><td>0x43 LL HH</td><td>3/2</td><td>Jump if C=1 (carry)</td></tr>
      <tr><td>JNC addr</td><td>0x44 LL HH</td><td>3/2</td><td>Jump if C=0</td></tr>
      <tr><td>JN addr</td><td>0x45 LL HH</td><td>3/2</td><td>Jump if N=1 (negative)</td></tr>
      <tr><td>JP addr</td><td>0x46 LL HH</td><td>3/2</td><td>Jump if N=0 (positive)</td></tr>
      <tr><td>JV addr</td><td>0x47 LL HH</td><td>3/2</td><td>Jump if V=1 (overflow)</td></tr>
      <tr><td>JSR addr</td><td>0x48 LL HH</td><td>6</td><td>Subroutine call (push PC to stack)</td></tr>
      <tr><td>RTS</td><td>0x49</td><td>5</td><td>Return from subroutine</td></tr>
    </table>

    <h3>5.6 Stack Instructions</h3>
    <table>
      <tr><th>Mnemonic</th><th>Opcode</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>PUSH A</td><td>0x50</td><td>3</td><td>Push A to stack</td></tr>
      <tr><td>PUSH B</td><td>0x51</td><td>3</td><td>Push B to stack</td></tr>
      <tr><td>PUSH X</td><td>0x52</td><td>3</td><td>Push X to stack</td></tr>
      <tr><td>PUSH Y</td><td>0x53</td><td>3</td><td>Push Y to stack</td></tr>
      <tr><td>POP A</td><td>0x54</td><td>3</td><td>Pop from stack to A</td></tr>
      <tr><td>POP B</td><td>0x55</td><td>3</td><td>Pop from stack to B</td></tr>
      <tr><td>POP X</td><td>0x56</td><td>3</td><td>Pop from stack to X</td></tr>
      <tr><td>POP Y</td><td>0x57</td><td>3</td><td>Pop from stack to Y</td></tr>
    </table>

    <h3>5.7 Special Instructions</h3>
    <table>
      <tr><th>Mnemonic</th><th>Opcode</th><th>Cycles</th><th>Description</th></tr>
      <tr><td>CLC</td><td>0x60</td><td>1</td><td>Clear carry flag</td></tr>
      <tr><td>SEC</td><td>0x61</td><td>1</td><td>Set carry flag</td></tr>
      <tr><td>CLI</td><td>0x62</td><td>1</td><td>Disable interrupts (future)</td></tr>
      <tr><td>SEI</td><td>0x63</td><td>1</td><td>Enable interrupts (future)</td></tr>
      <tr><td>HALT</td><td>0xFF</td><td>1</td><td>Stop CPU</td></tr>
    </table>

    <div class="important">
      <strong>Total Instructions:</strong> ~70 instructions (including NOP)<br>
      <strong>Addressing Modes:</strong> Immediate, Direct, Zero Page, Indexed (X/Y)
    </div>

    <h2>6. Sample Programs</h2>

    <h3>6.1 Screen Fill (256x256 Support)</h3>
    <pre>; Fill entire screen with red (palette #2) - 256x256=65536 pixels
; VRAM address: 0x8000-0xFFFF

LD A, #2           ; Color #2 = red
LD X, #0           ; Initialize X counter
LD Y, #0           ; Initialize Y counter

FILL_OUTER:
  LD B, #0         ; Inner loop counter

  FILL_INNER:
    ; Address calculation: 0x8000 + Y*256 + X
    ; Simplified: direct VRAM write
    ST A, [0x8000+X] ; Note: requires dynamic calculation
    INC X
    INC B
    CMP B, #0        ; Check if 256 iterations complete
    JNE FILL_INNER
  
  INC Y
  CMP Y, #0          ; Check if 256 lines complete
  JNE FILL_OUTER

HALT</pre>

    <h3>6.2 Sprite Display</h3>
    <pre>; Display sprite 0 at coordinates (100, 100)

LD A, #100         ; X coordinate
ST A, [0xD100]     ; Sprite 0 X
LD A, #100         ; Y coordinate  
ST A, [0xD101]     ; Sprite 0 Y
LD A, #0           ; Tile number 0
ST A, [0xD102]     ; Sprite 0 tile
LD A, #1           ; Enable flag
ST A, [0xD103]     ; Sprite 0 enable

HALT</pre>

    <h3>6.3 Sound Playback (A4 Note)</h3>
    <pre>; Play A4 (440Hz) on channel 0

LD A, #0x1C        ; Frequency low byte (284 = 0x011C)
ST A, [0xD200]     ; ch0 frequency L
LD A, #0x01        ; Frequency high byte
ST A, [0xD201]     ; ch0 frequency H
LD A, #15          ; Maximum volume
ST A, [0xD202]     ; ch0 volume
LD A, #2           ; 50% duty cycle
ST A, [0xD203]     ; ch0 duty
LD A, #1           ; Enable flag
ST A, [0xD205]     ; ch0 enable

; Wait ~1 second (60 frames)
LD C, #60
WAIT_LOOP:
  ; VBlank wait (implementation dependent)
  DEC C
  CMP C, #0
  JNE WAIT_LOOP

; Stop sound
LD A, #0
ST A, [0xD205]     ; ch0 disable

HALT</pre>

    <h3>6.4 Controller Input</h3>
    <pre>; Fill screen red when A button is pressed

MAIN_LOOP:
  LD A, [0xD300]   ; Read controller 1
  AND A, #0x10     ; Check bit4 (A button)
  CMP A, #0
  JE MAIN_LOOP     ; Loop if not pressed
  
  ; A button pressed
  LD A, #2         ; Red color
  ; ... screen fill routine ...
  
  JMP MAIN_LOOP

HALT</pre>

    <h2>7. Implementation Guide (JavaScript)</h2>

    <h3>7.1 Basic Structure</h3>
    <pre>class XVM16 {
  constructor() {
    // Registers
    this.A = 0;
    this.B = 0;
    this.C = 0;
    this.D = 0;
    this.X = 0;
    this.Y = 0;
    this.SP = 0x7FFF;
    this.PC = 0xE000;
    this.F = 0; // Z, C, N, V
    
    // Memory
    this.ram = new Uint8Array(0x8000);      // 32KB RAM (0x0000-0x7FFF)
    this.vram = new Uint8Array(0x10000);    // 64KB VRAM (0x8000-0xFFFF = 256*256)
    this.palette = new Uint8Array(256);     // 256 color palette
    this.spriteAttr = new Uint8Array(256);  // Sprite attributes (64*4)
    this.spriteTiles = new Uint8Array(0x4000); // Sprite tiles 16KB
    this.soundRegs = new Uint8Array(256);   // Sound registers
    this.ioRegs = new Uint8Array(256);      // I/O registers
    this.rom = new Uint8Array(0x2000);      // 8KB ROM
    
    // Initialize default palette
    this.initDefaultPalette();
    
    this.halted = false;
    this.cycles = 0;
  }
  
  initDefaultPalette() {
    const defaults = [
      0x00, 0xFF, 0xE0, 0x1C, 0x03, 0xFC, 0xE3, 0x1F,
      0x92, 0x6D, 0xB8, 0x9F, 0x13, 0xA3, 0xFD, 0xB6
    ];
    for (let i = 0; i < 16; i++) {
      this.palette[i] = defaults[i];
    }
  }
}</pre>

    <h3>7.2 Extended Memory Access</h3>
    <pre>read8(addr) {
  addr &= 0xFFFF;
  
  // RAM
  if (addr < 0x8000) return this.ram[addr];
  
  // VRAM
  if (addr < 0x10000) return this.vram[addr - 0x8000];
  
  // Palette (0xD000-0xD0FF overlaps VRAM but special handling)
  if (addr >= 0xD000 && addr < 0xD100) return this.palette[addr - 0xD000];
  
  // Sprite attributes
  if (addr >= 0xD100 && addr < 0xD200) return this.spriteAttr[addr - 0xD100];
  
  // Sound registers
  if (addr >= 0xD200 && addr < 0xD300) return this.soundRegs[addr - 0xD200];
  
  // I/O registers
  if (addr >= 0xD300 && addr < 0xD400) return this.ioRegs[addr - 0xD300];
  
  // ROM
  if (addr >= 0xE000) return this.rom[addr - 0xE000];
  
  return 0;
}

write8(addr, val) {
  addr &= 0xFFFF;
  val &= 0xFF;
  
  // RAM
  if (addr < 0x8000) {
    this.ram[addr] = val;
    return;
  }
  
  // VRAM (0x8000-0xFFFF but 0xD000+ is special)
  if (addr >= 0x8000 && addr < 0xD000) {
    this.vram[addr - 0x8000] = val;
    return;
  }
  
  // Palette
  if (addr >= 0xD000 && addr < 0xD100) {
    this.palette[addr - 0xD000] = val;
    // Also write to VRAM (overlap region)
    this.vram[addr - 0x8000] = val;
    return;
  }
  
  // Sprite attributes
  if (addr >= 0xD100 && addr < 0xD200) {
    this.spriteAttr[addr - 0xD100] = val;
    this.vram[addr - 0x8000] = val;
    return;
  }
  
  // Sound registers
  if (addr >= 0xD200 && addr < 0xD300) {
    this.soundRegs[addr - 0xD200] = val;
    this.updateSound(addr - 0xD200, val); // Update sound
    return;
  }
  
  // I/O registers (some are read-only)
  if (addr >= 0xD300 && addr < 0xD400) {
    // 0xD300-0xD301 are controller (read-only)
    if (addr >= 0xD302) {
      this.ioRegs[addr - 0xD300] = val;
    }
    return;
  }
}</pre>

    <h3>7.3 Display Rendering (256x256 Support)</h3>
    <pre>updateDisplay(canvas) {
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(256, 256);
  const pixels = imageData.data;
  
  // BG rendering
  for (let y = 0; y < 256; y++) {
    for (let x = 0; x < 256; x++) {
      const colorIdx = this.vram[y * 256 + x];
      const rgb332 = this.palette[colorIdx];
      const [r, g, b] = this.rgb332ToRGB(rgb332);
      
      const offset = (y * 256 + x) * 4;
      pixels[offset] = r;
      pixels[offset + 1] = g;
      pixels[offset + 2] = b;
      pixels[offset + 3] = 255;
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
  
  // Sprite rendering
  this.drawSprites(ctx);
}

drawSprites(ctx) {
  for (let i = 0; i < 64; i++) {
    const baseAddr = i * 4;
    const x = this.spriteAttr[baseAddr];
    const y = this.spriteAttr[baseAddr + 1];
    const tile = this.spriteAttr[baseAddr + 2];
    const flags = this.spriteAttr[baseAddr + 3];
    
    // If bit0 is 0, sprite is disabled
    if (!(flags & 0x01)) continue;
    
    const flipX = (flags & 0x02) !== 0;
    const flipY = (flags & 0x04) !== 0;
    
    // Load tile data (16x16 = 256 bytes)
    const tileData = this.spriteTiles.slice(tile * 256, (tile + 1) * 256);
    
    // Draw sprite
    for (let sy = 0; sy < 16; sy++) {
      for (let sx = 0; sx < 16; sx++) {
        const colorIdx = tileData[sy * 16 + sx];
        if (colorIdx === 0) continue; // Transparent color
        
        const rgb332 = this.palette[colorIdx];
        const [r, g, b] = this.rgb332ToRGB(rgb332);
        
        const px = x + (flipX ? (15 - sx) : sx);
        const py = y + (flipY ? (15 - sy) : sy);
        
        if (px >= 0 && px < 256 && py >= 0 && py < 256) {
          const offset = (py * 256 + px) * 4;
          const imageData = ctx.getImageData(0, 0, 256, 256);
          imageData.data[offset] = r;
          imageData.data[offset + 1] = g;
          imageData.data[offset + 2] = b;
          ctx.putImageData(imageData, 0, 0);
        }
      }
    }
  }
}

rgb332ToRGB(val) {
  const r = ((val >> 5) & 0x07) * 36;
  const g = ((val >> 2) & 0x07) * 36;
  const b = (val & 0x03) * 85;
  return [r, g, b];
}</pre>

    <h3>7.4 Sound Implementation (Web Audio API)</h3>
    <pre>initAudio() {
  this.audioCtx = new AudioContext({ sampleRate: 44100 });
  this.channels = [];
  
  for (let i = 0; i < 4; i++) {
    const oscillator = this.audioCtx.createOscillator();
    const gainNode = this.audioCtx.createGain();
    
    oscillator.type = 'square';
    oscillator.frequency.value = 440;
    gainNode.gain.value = 0;
    
    oscillator.connect(gainNode);
    gainNode.connect(this.audioCtx.destination);
    oscillator.start();
    
    this.channels.push({ oscillator, gainNode, enabled: false });
  }
}

updateSound(regOffset, value) {
  const ch = Math.floor(regOffset / 8);
  const reg = regOffset % 8;
  
  if (ch >= 4) return;
  
  const channel = this.channels[ch];
  const baseAddr = ch * 8;
  
  switch(reg) {
    case 0: // Frequency low byte
    case 1: // Frequency high byte
      const freqValue = this.soundRegs[baseAddr] | (this.soundRegs[baseAddr + 1] << 8);
      const freq = 4000000 / (32 * (freqValue || 1));
      channel.oscillator.frequency.value = freq;
      break;
      
    case 2: // Volume
      const volume = value / 15.0;
      channel.gainNode.gain.value = channel.enabled ? volume : 0;
      break;
      
    case 3: // Duty cycle
      // Implemented with PeriodicWave in Web Audio
      break;
      
    case 5: // Flags
      channel.enabled = (value & 0x01) !== 0;
      const volume2 = this.soundRegs[baseAddr + 2] / 15.0;
      channel.gainNode.gain.value = channel.enabled ? volume2 : 0;
      break;
  }
}</pre>

    <h3>7.5 Input Handling</h3>
    <pre>initInput() {
  this.controller1 = 0;
  this.controller2 = 0;
  
  // Keyboard mapping
  const keyMap = {
    'ArrowUp': 0x01,
    'ArrowDown': 0x02,
    'ArrowLeft': 0x04,
    'ArrowRight': 0x08,
    'KeyZ': 0x10,      // A button
    'KeyX': 0x20,      // B button
    'Enter': 0x40,     // START
    'ShiftRight': 0x80 // SELECT
  };
  
  window.addEventListener('keydown', (e) => {
    if (keyMap[e.code]) {
      this.controller1 |= keyMap[e.code];
      this.ioRegs[0] = this.controller1;
    }
  });
  
  window.addEventListener('keyup', (e) => {
    if (keyMap[e.code]) {
      this.controller1 &= ~keyMap[e.code];
      this.ioRegs[0] = this.controller1;
    }
  });
  
  // Random number generator
  setInterval(() => {
    this.ioRegs[2] = Math.floor(Math.random() * 256);
  }, 16);
  
  // Frame counter
  this.frameCount = 0;
}

updateFrameCounter() {
  this.frameCount++;
  this.ioRegs[3] = this.frameCount & 0xFF;       // Low byte
  this.ioRegs[4] = (this.frameCount >> 8) & 0xFF; // High byte
}</pre>

    <h2>8. Memory Layout Example</h2>

    <pre>Complete Memory Map (64KB):

0x0000 ┌─────────────────┐
       │ Zero Page RAM   │ 256B  Fast access variable area
0x0100 ├─────────────────┤
       │ Stack           │ 256B  Subroutines/interrupts
0x0200 ├─────────────────┤
       │ General RAM     │ 31.5KB Program data/workspace
0x2000 ├─────────────────┤
       │ Sprite Tiles    │ 16KB  256 16x16 tiles
0x6000 ├─────────────────┤
       │ General RAM cont│ 8KB
0x8000 ├─────────────────┤
       │ VRAM (BG)       │ 64KB  256x256 pixels
       │                 │       (0x8000-0xFFFF)
0xD000 ├─ ─ ─ ─ ─ ─ ─ ─ ┤ ※Overlaps VRAM
       │ Palette         │ 256B  256 color RGB332
0xD100 ├─ ─ ─ ─ ─ ─ ─ ─ ┤
       │ Sprite Attr     │ 256B  64 sprites x 4 bytes
0xD200 ├─ ─ ─ ─ ─ ─ ─ ─ ┤
       │ Sound Registers │ 256B  4ch x 8 bytes
0xD300 ├─ ─ ─ ─ ─ ─ ─ ─ ┤
       │ I/O Registers   │ 256B  Input/misc
0xD400 ├─────────────────┤
       │ VRAM continued  │
0xE000 ├─────────────────┤
       │ ROM             │ 8KB   Program code
0xFFFF └─────────────────┘</pre>

    <h2>9. Recommended Development Tools</h2>

    <h3>9.1 Assembler</h3>
    <p>Recommended: Implement custom assembler (mnemonic → machine code conversion)</p>
    
    <h3>9.2 Graphics Tools</h3>
    <ul>
      <li>Tile editor (create 16x16 sprites)</li>
      <li>Palette editor (RGB332 conversion)</li>
      <li>Map editor (BG layout)</li>
    </ul>

    <h3>9.3 Sound Tools</h3>
    <ul>
      <li>MML compiler (Music Macro Language)</li>
      <li>Frequency table generator</li>
    </ul>

    <h2>10. Performance Targets</h2>

    <table>
      <tr><th>Metric</th><th>Target</th></tr>
      <tr><td>Frame Rate</td><td>60 FPS (fixed)</td></tr>
      <tr><td>Render Time</td><td>< 5ms/frame</td></tr>
      <tr><td>CPU Usage</td><td>< 30%</td></tr>
      <tr><td>Boot Time</td><td>< 100ms</td></tr>
    </table>

    <h2>11. Extended Specifications (Optional)</h2>

    <h3>11.1 Future Extensions</h3>
    <ul>
      <li>Interrupt system (VBlank/Timer/External)</li>
      <li>DMA transfer (fast memory copy)</li>
      <li>Hardware scrolling</li>
      <li>Multiple BG layers (2-4 layers)</li>
      <li>Noise/triangle wave channels</li>
      <li>PCM sample playback</li>
      <li>Save data (EEPROM/Battery Backup)</li>
      <li>Multiplayer communication</li>
    </ul>

    <div style="margin-top: 50px; padding: 25px; background: #0a0a0a; border: 2px solid #0f0; text-align: center;">
      <h3 style="color: #0f0; margin-top: 0;">XVM-16 Complete Specification v1.0</h3>
      <p style="color: #888; margin: 10px 0;">
        256x256 Resolution | 256 Colors | 4ch Sound | 64 Sprites<br>
        Extended Instruction Set 70+ | Game Development Ready
      </p>
      <p style="color: #0ff; font-size: 12px; margin-top: 15px;">
        CC0 Public Domain - Free to use, modify, and distribute
      </p>
    </div>

  </div>
</body>
</html>
